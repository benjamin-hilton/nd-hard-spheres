import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np
import scipy.special
import warnings


class Simulation:
    """
    The Simulation class operates on a Gas object, updating that object every time interval.
    """
    def __init__(self, frame_time, gas):
        """
        Initialises the Simulation class.

        Arguments:
            - frame_time: The time between updates of the gas.
            - Gas: A Gas object to update.
        """
        self.frame_time = frame_time
        self.gas = gas

        print "Simulation active."

    def next_frame(self, frame):
        """
        Updates the gas to the next frame.

        Arguments:
            - frame: The frame number the simulation is currently on, an integer.
        """

        delta_t = 0

        if self.gas.next_collision_time < self.frame_time * (frame + 1):
            delta_t = (self.gas.simulate((frame + 1) * self.frame_time, start_time=frame * self.frame_time)
                       - self.frame_time * frame)

        for item in self.gas.balls:
            item.move(self.frame_time - delta_t)


class Movie(Simulation):
    """
    The Movie class inherits from the Simulation class and also creates a matplotlib animation of the simulation.
    """
    def __init__(self, gas, frames=None, frame_time=0.01, interval=1, x_lim=(-11, 11), y_lim=(-11, 11)):
        """
        Initialise the Movie class.

        Arguments:

            - gas: A ball.Gas object to animate to form the movie.
            - frames: The number of frames the movie should run for. If none, the movie runs indefinitely but cannot be saved.
            - frame_time: The time between each frame simulated to form the movie.
            - interval: The time, in ms, between each frame being drawn. Sets the frame rate.
            - x_lim: A tuple containing the lower and upper limits of the x-axis.
            - y_lim: A tuple containing the lower and upper limits of the y-axis.
        """

        self.fig = plt.figure()
        self.ax = plt.axes(xlim=x_lim, ylim=y_lim)
        self.ax.axes.set_aspect("equal")
        self.frames = frames
        self.interval = interval

        Simulation.__init__(self, frame_time, gas)

    def get_animation(self):
        """
        Returns the matplotlib animation generated by the movie.
        """

        if self.gas.dimensions != 2:
            warnings.warn("Warning: The animation shows a 2-D projection of the gas onto the x-y plane through the origin.")

        return animation.FuncAnimation(self.fig, self.next_frame, frames=self.frames, init_func=self.init_figure,
                                       interval=self.interval, blit=True)

    def init_figure(self):
        """
        Initialise the gas and add it to a plot.

        Returns:
            - A list of the patches in the plot.
        """
        patches = []

        for item in self.gas.balls:
            patch = item.patch()
            self.ax.add_patch(patch)
            patches.append(patch)

        return patches

    def next_frame(self, frame):
        """
        Updates the patches for the next frame in the animation.

        Arguments:
            - frame: The current frame number.
        Returns:
            - A list of the patches in the plot.
        """

        Simulation.next_frame(self, frame)

        patches = []

        for item in self.gas.balls:
            patches.append(item.patch())

        return patches


class Plotter (Simulation):
    """
    A class for running a simulation and returning important values at certain time intervals for plotting.
    """
    def __init__(self, gas, frame_time=0.1, end_frame=60, funcs=None):
        """
        Initialise the Plotter class.
        Creates a dictionary of variables including:
            - Container volume if a container exists.
            - The value of each function in funcs at each frame.

        Arguments:

            - gas: A ball.Gas object to animate to form the movie.
            - frame_time: The time between each frame simulated to form the movie.
            - end_frame: The frame at which to stop simulating.
            - funcs: A list of instances of MeasureFunc.
        """

        Simulation.__init__(self, frame_time, gas)
        self.end_frame = end_frame

        self.funcs = funcs or []
        self.variables = {}
        self.dist_data = {}

        for func in self.funcs:
            self.variables[func.func_name] = []

        if self.gas.balls[0].radius < 0:
            self.variables["volume"] = abs((((np.pi ** (self.gas.dimensions / 2.))
                                             / (scipy.special.gamma((self.gas.dimensions / 2. + 1))))
                                            * self.gas.balls[0].radius ** self.gas.dimensions))

        for frame in xrange(self.end_frame):
            self.next_frame(frame)

    def plot(self):
        """
        Returns the plots of self.variables based off the plot_type of each function in self.funcs.
        Functions of plot_type "time" are plotted against time.
        Functions of plot_type "distribution" are plotted as a histogram using bin_number of that function.
        Functions of plot_type "drawing" are drawn onto a diagram of the gas.
        """

        figures = {}

        for func in self.funcs:

            if func.plot_type == "time":
                fig = plt.figure()

                x = np.arange(self.end_frame) * self.frame_time
                y = self.variables[func.func_name]

                plt.plot(x, y, "b.")

                plt.grid()
                plt.xlabel(r"$\rm Time $", fontsize=25)
                plt.ylabel(r"$\rm " + func.func_name.replace("_", "\ ").title() + "$", fontsize=25)

                figures[func.func_name] = fig

            if func.plot_type == "distribution":
                fig = plt.figure()

                x = np.array(self.variables[func.func_name][int(-self.end_frame / 4):]).flatten()
                x = [i for i in x if i is not None]

                self.dist_data[func.func_name] = plt.hist(x, bins=func.bin_number, normed=True)

                print "Mean " + func.func_name.replace("_", " ").title() + " =", np.mean(x)

                plt.grid()
                plt.xlabel(r"$\rm " + func.func_name.replace("_", "\ ").title() + "$", fontsize=25)
                plt.ylabel(r"$\rm Probability\ Density$", fontsize=25)

                figures[func.func_name] = fig

            if func.plot_type == "drawing":

                fig = plt.figure()

                data = np.array(self.variables[func.func_name]).T
                x = data[0]
                y = data[1]

                axis = abs(self.gas.balls[0].radius) + 1
                ax = plt.axes(xlim=(-axis, axis), ylim=(-axis, axis))
                ax.axes.set_aspect("equal")
                ax.add_patch(self.gas.balls[0].patch())
                print self.gas.balls[0].patch()

                plt.plot(x, y, "b-")

                plt.grid()
                plt.xlabel(r"$\rm y$", fontsize=25)
                plt.ylabel(r"$\rm x$", fontsize=25)

                figures[func.func_name] = fig

        return figures

    def next_frame(self, frame):
        """
        Updates the simulation to the next frame and gets the values of the functions at that frame.
        Prints the current simulation time.

        Arguments:
            - frame: The frame number the simulation is currently on.
        """

        print "Time:", frame * self.frame_time

        Simulation.next_frame(self, frame)
        self.get_values(frame)

    def get_values(self, frame):
        """
        Obtains the value of each function in self.funcs at the current frame.

        Arguments:
             - frame: The frame number the simulation is currently on.
        """
        for func in self.funcs:
            self.variables[func.func_name].append(func(self.gas, frame * self.frame_time))